!>  subroutine of reading data from the previous cycle
!! in the file recup.tmp generated by the previous run
!!
! ******************************************************************
  subroutine Lecture_DonneesCyclePrecedent(sc,pg,p,itk,soil) !,c,sta,t)
! ******************************************************************
  USE Stics
  USE Plante
  USE Itineraire_Technique
  USE Sol
!  USE Climat
!  USE Station
  USE Parametres_Generaux
  USE Divers

  implicit none

  type(Stics_Communs_),       intent(INOUT) :: sc  
  type(Parametres_Generaux_), intent(INOUT) :: pg
  type(Plante_),              intent(INOUT) :: p (sc%P_nbplantes)
  type(ITK_),                 intent(INOUT) :: itk (sc%P_nbplantes)
  type(Sol_),                 intent(INOUT) :: soil  
!  type(Climat_),              intent(INOUT) :: c
!  type(Station_),             intent(INOUT) :: sta
!  type(Stics_Transit_),       intent(INOUT) :: t

! dr 25/09/2014 resuuite0 danscette version comporte au plus 31 caracteres et non 7 comme dans la 69, je corrige .
      character(len=31)   :: ressuite0(2)
!!!MODIF HISAFE 1 : suppression des chaines de caractères
!!!      character(len=8)   :: codeplante0(2)
      integer   :: codeplante0(2)
      character(len=250) :: tmp  
      integer            :: idx
      integer            :: i
      integer            :: ir
      integer            :: icou
      integer            :: ifwater0p1
      integer :: nbresid        ! nombre de types de résidus en mulch

  character(len=12) :: P_typsol  !< // PARAMETER // Soil type // * // PARSOL // 1
  character(len=255) :: datapath ! enabling_record
  character(len=255) :: sticsid


! pour record
      integer ib1, ib2                                       ! enabling_record
      character(len=300) :: filepluspath                      ! enabling_record
       ! to get the full path

      ib1 = len_trim(datapath)                             ! enabling_record
      ib2 = len_trim(sticsid)                              ! enabling_record
      if (ib1 .eq. 0 ) then                                   ! enabling_record
         filepluspath = 'recup.tmp'
      else
         if (ib2 .eq. 0 ) then
            filepluspath = datapath(1:ib1) // '/tmp/' // 'recup.tmp'  ! enabling_record
         else
            filepluspath = datapath(1:ib1) // '/tmp/' // 'recup_' // sticsid(1:ib2) // '.tmp'  ! enabling_record
         endif
      endif                                                   ! enabling_record
!   write(*,*), 'read :', filepluspath


 ! fin record

      nbresid = (pg%nbResidus-1)/2

   ! ouverture du fichier
!      open(12,file = 'recup.tmp',status = 'unknown')
        open(12,file = filepluspath, status = 'unknown')

!  write(5588,*)'debut lecture recup iwater',sc%P_iwater,'ifwater',sc%P_ifwater

      ! lecture de la première ligne
!        read(12,610) sc%nbjrecol0, sc%ifwater0, sc%nhe, sc%dernier_n
        read(12,*) sc%nbjrecol0, sc%ifwater0, sc%nhe, sc%dernier_n
!!!  610   format(4i10)

!        read(12,610) ansemis_avant,anrecol_avant,P_iwater_avant,P_ifwater_avant

        ! TODO : P_codeperenne, sur la plante principale ? sur toutes les plantes ?
!        if (sc%numcult > 1 .and. p(1)%P_codeperenne /= 2) then
!          if (sc%ifwater0 == sc%nbjrecol0) then
!            sc%P_iwater = 1
!          else
!            sc%P_iwater = sc%ifwater0 + 1
!          endif
!        endif

        ! TODO : P_codeperenne, sur la plante principale ? sur toutes les plantes ?
        if (sc%ifwater0 == sc%nbjrecol0 .and. p(1)%P_codeperenne /= 2) then
          if (sc%P_iwater /= 1) then
            call EnvoyerMsgHistorique(3045)
            if(.not.sc%flag_record) call exit(9) !stop
          endif
        else
        ! PB 04/2010 : on cherche à comparer P_iwater au jour de fin du cycle précédent + 1
        ! (le cycle doit reprendre le jour suivant celui de fin du cycle précedent)
        ! mais si le cycle précédent s'est terminé le dernier jour de l'année (365 par ex.)
        ! alors, le jour suivant est 366, alors que P_iwater a déjà était affecté à 1.
        ! Et donc le test P_iwater /= ifwater0 + 1 est tjs vrai (1 /= 366)
        ! Pour pallier à ce problème, on borne ifwater0 + 1 par nbjrecol0 (nb de jours de l'année du cycle précédent)
        ! Le jour 366 devient le jour 1, et donc le test devient faux et le programme ne s'interrompt pas
        ! sur une mauvaise interprétation.
          ifwater0p1 = sc%ifwater0 + 1
          if (ifwater0p1 > sc%nbjrecol0) ifwater0p1 = ifwater0p1 - sc%nbjrecol0
          if (sc%P_iwater /= ifwater0p1) then
            call EnvoyerMsgHistorique(3045)
            if(.not.sc%flag_record)call exit(9) !stop
          endif
        endif

!!!MODIF HISAFE 7 : Déplacement de variables (de Stics.f90 dans Sol.f90)
 !!!       read(12,*) (sc%Hinit(i),i = 1,5)
        read(12,*) (soil%Hinit(i),i = 1,5)
        read(12,*) (soil%NO3init(i),i = 1,5)
 !!!       read(12,*) (sc%NH4init(i),i = 1,5)
        read(12,*) (soil%NH4init(i),i = 1,5)
 !!!       read(12,*) (sc%TS(i),i = 1,5)
        read(12,*) (soil%TS(i),i = 1,5)
        read(12,*)   sc%tcultveille, sc%tairveille
        sc%tcult = sc%tcultveille
!!!  620   format(25e10.4)

 !  Bruno mai 2012 : prise en compte de tous les pools C et N organiques
        read(12,*) sc%Chumt,sc%Chuma,sc%Chumi,sc%Nhumt,sc%Nhuma,sc%Nhumi,sc%Cr,sc%Nr,sc%Cb,sc%Nb,sc%Cmulchnd,sc%Nmulchnd, &
                     sc%Cmulchdec,sc%Nmulchdec,sc%Cbmulch,sc%Nbmulch
 !  Bruno  Initialisations pour bilan
        sc%Nb0 = sc%Nb
        sc%Cb0 = sc%Cb
        sc%Nr0 = sc%Nr
        sc%Cr0 = sc%Cr
 !       sc%Cmulch0 = sc%Cmulch
 !       sc%Nmulch0 = sc%Nmulch
 ! Elsa sept2012 : Cmulch et Nmulch n'ont pas été transmis donc on refait la somme ici
        sc%Cmulch0 = sc%Cmulchdec + sc%Cmulchnd
        sc%Nmulch0 = sc%Nmulchdec + sc%Nmulchnd
        sc%Cbmulch0 = sc%Cbmulch
        sc%Nbmulch0 = sc%Nbmulch


 ! lecture des parametres de decomposition des differents types de residus
 !  Bruno aout 2012 : ajout de Cnondec et Nnondec
      do ir = 1,pg%nbResidus
         read(12,*) sc%kres(ir),pg%P_kbio(ir),sc%hres(ir),sc%Wb(ir)
      end do
      do ir = 1,nbResid
         read(12,*) sc%Cnondec(ir),sc%Nnondec(ir)
      end do

 !  Bruno mai 2012 : ajout de Nres et Nhum
        do i = 1,40
          read(12,*) (sc%Cres(i,ir),ir = 1,pg%nbResidus)
          read(12,*) (sc%Nres(i,ir),ir = 1,pg%nbResidus)
          read(12,*) (sc%Cbio(i,ir),ir = 1,pg%nbResidus)
          read(12,*) (sc%Nbio(i,ir),ir = 1,pg%nbResidus)
          read(12,*)  sc%Chum(i), sc%Nhum(i)
        end do

 ! lecture de l'état du sol, couche élementaire (1 cm) par couche élémentaire
 !  Bruno mai 2012 : separation de hur(i) et sat(i)
        do  i = 1, sc%nhe
          read(12,*) sc%hur(i), sc%sat(i), soil%nit(i), soil%amm(i), sc%tsolveille(i)
        end do

! DR 14/10/2011 mise en conformité param.sol
!          read(12,*) soil%P_numsol,soil%P_typsol,soil%P_argi,soil%P_Norg,soil%P_profhum,soil%P_calc,soil%P_pH,  &
!                   soil%P_concseuil,soil%P_albedo,soil%P_q0,soil%P_ruisolnu,soil%P_obstarac
        read(12,*)soil%P_numsol,P_typsol,soil%P_argi,soil%P_Norg,soil%P_profhum,soil%P_calc,soil%P_pH,&
                          soil%P_concseuil,soil%P_albedo,soil%P_q0,soil%P_ruisolnu,soil%P_obstarac,soil%P_pluiebat, &
                          soil%P_mulchbat,soil%P_zesx,soil%P_cfes,soil%P_z0solnu ,soil%P_CsurNsol, soil%P_penterui
                    ! DR 22/08/2012 j'ajoute les 2 parametres  ,soil%P_CsurNsol, soil%P_penterui

! DR 14/10/2011 mise en conformité param.sol
!        read(12,*) soil%P_numsol,soil%P_codecailloux,soil%P_codemacropor,soil%P_codefente,  &
!                   soil%P_codrainage,soil%P_coderemontcap,soil%P_codenitrif
      read(12,*) soil%P_numsol,soil%P_codecailloux,soil%P_codemacropor,soil%P_codefente,   &
                          soil%P_codrainage,soil%P_coderemontcap,soil%P_codenitrif,soil%P_codedenit

! DR 14/10/2011 mise en conformité param.sol
!        read(12,*) soil%P_numsol,soil%P_capiljour,soil%P_humcapil,soil%P_profimper,soil%P_ecartdrain,soil%P_ksol,soil%P_profdrain
      read(12,*) soil%P_numsol,soil%P_profimper,soil%P_ecartdrain,soil%P_ksol,soil%P_profdrain,     &
                          soil%P_capiljour,soil%P_humcapil,soil%P_profdenit,soil%P_vpotdenit
 ! Ajout test Bruno mai 2012
        if(soil%P_profdenit==0) soil%P_profdenit = soil%P_profhum

        do icou = 1,5
         ! read(12,*) soil%P_numsol,soil%P_epc(icou),soil%P_hccf(icou),soil%P_hminf(icou),soil%DA(icou),  &  ! DR 02/10/2012
          read(12,*) soil%P_numsol,soil%P_epc(icou),soil%P_hccf(icou),soil%P_hminf(icou),soil%P_DAF(icou),  &  ! DR 02/10/2012
                     soil%P_cailloux(icou),soil%P_typecailloux(icou),soil%P_infil(icou),soil%P_epd(icou)
        end do

    ! domi 14/03/06 ecriture des caracteristiques permanentes du sol dans history
        call EnvoyerMsgHistorique(501)
        call EnvoyerMsgHistorique(502)

        write(tmp,'(a12,17f7.2)') P_typsol,soil%P_argi,soil%P_Norg,soil%P_profhum,     &
                                  soil%P_calc,soil%P_pH,soil%P_concseuil,soil%P_albedo,     &
                                  soil%P_q0,soil%P_ruisolnu,soil%P_obstarac,soil%P_pluiebat, &
                                  soil%P_mulchbat,soil%P_zesx,soil%P_cfes,soil%P_z0solnu,soil%P_CsurNsol, soil%P_penterui
                    ! DR 22/08/2012 j'ajoute les 2 parametres  ,soil%P_CsurNsol, soil%P_penterui

        call EnvoyerMsgHistorique(tmp)

        call EnvoyerMsgHistorique(503)

    ! DR 03/11/2005 rajout message pour expliquer les codes
        call EnvoyerMsgHistorique(215)

        write(tmp,'(2x,7i12)') soil%P_codecailloux,soil%P_codemacropor,soil%P_codefente,  &
                               soil%P_codrainage,soil%P_coderemontcap,soil%P_codenitrif,soil%P_codedenit
        call EnvoyerMsgHistorique(tmp)
        call EnvoyerMsgHistorique(504)
        ! 06/04/2012 je corrige le format d'ecriture depuis ajout profdenit et vpotdenit
        write(tmp,'(5x,8f9.1)')soil%P_profimper,soil%P_ecartdrain,soil%P_ksol,soil%P_profdrain,     &
                          soil%P_capiljour,soil%P_humcapil,soil%P_profdenit,soil%P_vpotdenit

        call EnvoyerMsgHistorique(tmp)

        call EnvoyerMsgHistorique(505)

        do icou = 1,5
          write(tmp,'(f7.0,2f7.1,f7.2,2f7.0,2i7)')                          &
!            soil%P_epc(icou),soil%P_hccf(icou),soil%P_hminf(icou),soil%DA(icou),  &  ! DR 02/10/2012
            soil%P_epc(icou),soil%P_hccf(icou),soil%P_hminf(icou),soil%P_DAF(icou),  &
            soil%P_cailloux(icou),soil%P_infil(icou),soil%P_epd(icou),soil%P_typecailloux(icou)
          call EnvoyerMsgHistorique(tmp)
        end do

    ! DR 29/05/08 maintenant on recupere pour les perennes le lai et le reste
    ! dans le cas d'un enchainement
    if (pg%P_codeinitprec == 2) then

        do idx = 1, sc%P_nbplantes
          read(12,*,end=900)
          read(12,*) codeplante0(idx)
          read(12,*) ressuite0(idx)
        ! on impose les residus de culture simules dans l'P_usm précédente
    ! 25/09/2014 DR modifs BM on ajoute un index pour tester l'appartenance de la chaine et non son egalite
    !      if (ressuite0(idx) == 'stubble+roots' .or. ressuite0(idx) == 'straw+roots' .or. ressuite0(idx) == 'whole_crop') then
          if (index(ressuite0(idx),'stubble+roots')>0 .or. index(ressuite0(idx),'straw+roots')>0  &
                                                      .or. index(ressuite0(idx),'whole_crop')>0) then
            if (itk(idx)%P_coderes(1) == 1 .or. itk(idx)%P_coderes(1) == 2) then
              itk(idx)%P_qres(1) = 0.
!              sc%flag_ressuite_enchaine =
            endif
          endif
         ! 27/07/2012 DR et ML on ajoute l possibilité d'avoir d'autres types de residus que 1 ou 2
    ! 25/09/2014 DR modifs BM on ajoute un index pour tester l'appartenance de la chaine et non son egalite
          if (index(ressuite0(idx),'stubble_of_residu_type_9+roots')>0   &
          .or.index(ressuite0(idx),'stubble_of_residu_type_10+roots')>0) then
            if (itk(idx)%P_coderes(1) == 9 .or. itk(idx)%P_coderes(1) == 10) then
              itk(idx)%P_qres(1) = 0.
            endif
          endif

          read(12,*) p(idx)%P_lai0,p(idx)%P_masec0,p(idx)%P_magrain0,  &
                     p(idx)%P_zrac0,p(idx)%P_QNplante0,p(idx)%P_resperenne0
          read(12,*) sc%cu0(idx) ! TODO : faire de cu0 une variable plante ?
          read(12,*) (p(idx)%P_densinitial(i),i = 1,5)

! DR le 14/04/2016 on va tenter de garder pour la prairie les varaibles mafeuiltombe, msneojaune et masecneo
          read(12,*) p(idx)%mafeuiltombe0(0:2), p(idx)%msneojaune0(0:2), p(idx)%masecneo0(0:2),&
          p(idx)%mafeuiljaune0(0:2),p(idx)%dltamsen0(0:2)

        end do

    ! DR 30/05/08 je teste qu'il n'y ai pas eu d'inversion dans la culture d'avant
        if (sc%P_nbplantes == 2 .and. (p(1)%P_codeplante /= codeplante0(1) .or. p(2)%P_codeplante /= codeplante0(2))) then
          call EnvoyerMsgHistorique(450)
        endif

    endif


900   close(12)

    ! domi 20/03/06 je le rajoute la sinon on ne refait pas tous les calculs d'initialisation
    !  verifier si il ne faut pas rajouter les calculs d'ini et regarder pour quoi ca bug quand on met ca
        soil%profsol = 0.
        do i = 1,5
          soil%profsol = soil%profsol + soil%P_epc(i)
        end do

return
end subroutine Lecture_DonneesCyclePrecedent
 
 
